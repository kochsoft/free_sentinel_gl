/**
 * Sentinel Gl -- an OpenGL based remake of the Firebird classic the Sentinel.
 * Copyright (C) May 25th, 2015 Markus-Hermann Koch, mhk@markuskoch.eu
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * */

/**
 * Io demands of the opengl project.
 * The most obvious being a method for reading in glsl code.
 */

#ifndef MHK_IO_H
#define MHK_IO_H

typedef unsigned char uchar;

#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <png.h>
//#include <GL/glew.h>
//#include <GL/gl.h>
//#include <GL/freeglut.h>
//#include <glm/glm.hpp>

using std::string;
using std::ifstream;
using std::istream;
using std::ostream;
using std::vector;
//using glm::vec2;
//using glm::vec3;
//using glm::vec4;
using std::cout;
using std::cerr;

namespace mhk_gl
{
/** Debugging level enum used by Io::print[ln](..) */
enum E_DEBUG_LEVEL { VERBOSE, MESSAGE, WARNING, ERROR, QUIET };

class Png_data
{
public:
	int width;
	int height;
	int bytes_per_pixel;
	png_byte bit_depth;
	png_byte color_type;
	// Each entry is a png_bytep (a pointer in itself) which points at the
	// beginning of one line within the png. Such a line has
	// bytes_per_pixel * width entries. And there are height such lines.
	png_bytep* data;
	
	/** Trivial constructor defining all properties as 0
	 * and free_data_upon_delete as false. */
	Png_data();
	
	/** Copy constructor. Makes a shallow copy of the input png. 
	 * Note that after this there will be two Png_data objects pointing
	 * at the same image data with their data pointers! Try not to
	 * double free them later on! :-) */
	Png_data(Png_data& input);
	
	/** Trivial constructor defining all values as given. */
	Png_data(int width, int height, int bytes_per_pixel,
		png_byte bit_depth, png_byte color_type, png_bytep* data);
	
	/** Copies this->data to a 1-dim uchar array. Mallocs appropriate memory.
	 * Returns a 0-Pointer instead if anything goes wrong. */
	uchar* copy_to_linear();
	
	string toString();
};
	
class Io
{
protected:
E_DEBUG_LEVEL debug_level;
ostream* stdout;
ostream* stderr;

public:
Io(E_DEBUG_LEVEL debug_level=E_DEBUG_LEVEL::MESSAGE, ostream* stdout=&cout, ostream* stderr=&cerr);

/** @return the string representation of the given debug_level or "UNKNOWN". */
static string debug_level_to_string(E_DEBUG_LEVEL debug_level);

/** Returns date time as returned by the C function asctime(..). */
static string get_date_time_string();

/** Debugging print functions
 * @param E_DEBUG_LEVEL debug_level: Send generated message to the appropriate output-stream
 *   if 1.) said stream is not a 0 pointer, 2.) (debug_level >= this->debug_level).
 *   In any case the message will be returned as string.
 * @param string prologue: Will be set before the message.
 * @param string message: Will be set after the prologue.
 * @param bool doDate: If true a date time string will be prefixed to the prologue.
 * @return The string generated by this call.
 */
string print(E_DEBUG_LEVEL debug_level, string prologue, string message, bool doDate=true);
/** Convenience wrapper suffixing the results of print(..) with a std::endl. */
string println(E_DEBUG_LEVEL debug_level, string prologue, string message, bool doDate=true);

/** Picks a directory name and a file name and builds
 * a dfname from them. */
static string build_dfname(string dname, string fname);

/** I like to have a separate function for the micro-task of getting
 * a ifstream. Why? This class will be inherited by a
 * Qt variation which will sport its own version of such a function
 * using Qt resources. However, this basic class I intend to keep clear
 * of Qt stuff.
 *   string pfname: Absolute path and file name for the target file.
 *   ifstream& in: Reference to target ifstream. Will be "open(..)"ed.
 *   std::ios_base::openmode mode: Opening mode. Consider
 *     std::ifstream::in | std::ifstream::binary for binary formats like png.
 * Note: For some reason it appears to be impossible to have a function
 * return an ifstream.
 */
static void get_ifstream(string pfname, ifstream& in,
	std::ios_base::openmode mode=std::ifstream::in);

/**
 * Attempts to return the contents of the given target file.
 * Intended for loading glsl source code.
 * @param string pfname: Target pfname.
 * @return "" if unable to read.  * */
static string read_file(istream& in);

/** Picks the given file and returns a vector of strings containing
 * the lines from the file. Newline characters are dropped.
 * @param istream& in: Instream reference.
 * @param boold drop_leading_ws: If true prior to each getline(..) the command
 *   in >> std::ws; will be issued.
 * @param char comment_char: May be 0 to disable this feature. Else the
 *   given character will denote the beginning of a comment.
 *   Note that the comment line must be the first character in the line.
 *   Hence "  # Bla" will only be recognized as comment if drop_leading_ws==true
 *   and if comment_char=='#'.
 * @param bool drop_empty_lines: If true empty lines will be ignored.
 */
static vector<string> read_file_by_lines(istream& in, bool drop_leading_ws=true,
	char comment_char='#', bool drop_empty_lines=true);


};

}
#endif
